<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: BestPractice | Mattes Groeger]]></title>
  <link href="http://MattesGroeger.github.io/blog/categories/bestpractice/atom.xml" rel="self"/>
  <link href="http://MattesGroeger.github.io/"/>
  <updated>2013-11-14T23:40:51+01:00</updated>
  <id>http://MattesGroeger.github.io/</id>
  <author>
    <name><![CDATA[Mattes Groeger]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Flash Timeline Actions]]></title>
    <link href="http://MattesGroeger.github.io/blog/2012/01/29/flash-timeline-actions/"/>
    <updated>2012-01-29T17:12:00+01:00</updated>
    <id>http://MattesGroeger.github.io/blog/2012/01/29/flash-timeline-actions</id>
    <content type="html"><![CDATA[<p>A proper designer-developer workflow is essential, especially in bigger teams. By separating logic and view (e.g. via <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC Design Pattern</a>) we try to avoid dependencies between artists and programmers. Less coupling increases the speed of development and design.</p>

<!-- more -->


<p>Sometimes it is hard to avoid this coupling, especially if it comes to optimization. Let&rsquo;s imagine an artist who wants to have sound within his timeline animation. He could just embed the sound and put it in the appropriate timeline frame. But if he then wants to use the same sound in another FLA it gets complicated. We don&rsquo;t want the same sound to be loaded twice.</p>

<p>This post describes a pattern for triggering more sophisticated logic from the Flash timeline so artists can easily make use of it. For easier understanding I will stick to the sound example. But keep in mind that this pattern can be applied to other problems as well. I will give an example at the end of this post.</p>

<p>Please also note that this post focuses on timeline related actions. If you want to trigger sounds based on mouse clicks or just playing background sounds, you are perfectly fine doing this purely by code.</p>

<h3>Alternative Approaches</h3>

<p>Before discussing the actual solution in detail, I would like to briefly mention two alternatives and their particular drawbacks.</p>

<p>I already mentioned one solution: Embedding sounds within their respective <code>FLA</code> files. But using the same sound in other <code>FLAs</code> would cause it to be loaded multiple times. The browser can&rsquo;t cache them either because they are embedded in different <code>SWF</code> files.</p>

<p>Another solution would be to trigger sounds programmatically by using frame labels. This means that your code would have to observe the timeline for execution of certain labels. You have to use some kind of configuration that tells the code which sound to play on which MovieClip and label. Parsing every MovieClip wouldn&rsquo;t be a good idea in terms of performance.</p>

<p>Both alternatives have a drawback either for artists or programmers. Wouldn&rsquo;t it be cool if we could trigger our logic from the timeline instead of heaving the logic observing it? Thats where &lsquo;Timeline Actions&rsquo; enter the stage.</p>

<h2>Timeline Actions</h2>

<p>This illustration shows the relevant parts that I&rsquo;ll explain in the following sections.</p>

<p>{% img center /images/posts/Graph.png Timeline Actions Overview %}</p>

<h3>The basic concept</h3>

<p>In the above image you can see two example asset files (red) which will be maintained by the artists. The sound logic (blue) is a separate <code>SWF</code> or part of the application maintained by the programmers. It&rsquo;s responsible for loading, caching and playing the sounds. The goal is, that artists can trigger any sound by putting the following frame script into the timeline:</p>

<p>{% codeblock lang:actionscript3 %}
playSound(&ldquo;mySound&rdquo;);
{% endcodeblock %}</p>

<p><em>Note</em>: Because the <code>playSound()</code> is a top-level function it requires no import statement.</p>

<p>The sound logic should receive the string <code>"mySound"</code> and select the appropriate MP3 for playback. But how do you communicate from the assets (red) to the sound logic (blue)? It&rsquo;s not a good idea to compile the sound logic into each asset. Thats why the first step is, to put just the communication logic into a very small library called &ldquo;<code>timeline-sound.swc</code>&rdquo; (green).</p>

<p>This library contains the <code>playSound()</code> function as well as a static <code>SoundDelegate</code> class. The <code>SoundDelegate</code> is the connection between <code>playSound()</code> and sound logic. The next section &ldquo;Technical implementation&rdquo; will give you more insight into the <code>SWC</code> contents.</p>

<p>{% img center /images/posts/ActionscriptSettings.png Advanced ActionScript 3.0 Settings %}</p>

<p>You can reference the <code>timeline-sound.swc</code> in each <code>FLA</code> now. Therefore open your <code>FLA</code> and navigate to <code>File -&amp;gt; ActionScript Settings...</code> Here go to the second tab &ldquo;<code>Library path</code>&rdquo; and select the &ldquo;<code>Browse to SWC file</code>&rdquo; button (1). After choosing the <code>timeline-sound.swc</code> it shows up in the panel underneath (2). Now you can use the <code>playSound()</code> function as frame script without getting a compiler error. At the same time your sound logic keeps separate.</p>

<h3>Technical implementation</h3>

<p>This section will explain how top-level function, delegate and sound logic get wired together. Therefore lets see what the contents of the <code>timeline-sound.swc</code> are. You can <a href="https://github.com/MattesGroeger/as3-timeline-sound">browse and download the source code from GitHub</a> or just read on.</p>

<p>{% img center /images/posts/TimelineSoundContents.png Contents of &#39;timeline-sound.swc&#39; %}</p>

<p>The <code>SoundDelegate</code> contains only static methods. Therefore it can be reached from anywhere in the application (including the top-level function <code>playSound()</code>). It&rsquo;s implementation is rather simple. It basically just holds a reference to another instance that it delegates to (line 17). Again, for encapsulation reasons this is implemented as an interface <code>ISoundAdapter</code> (line 3).</p>

<p>{% codeblock lang:actionscript3 %}
public class SoundDelegate
{
  private static var adapter:ISoundAdapter;</p>

<p>  public static function init(adapter:ISoundAdapter = null):void
  {</p>

<pre><code>SoundDelegate.adapter = (adapter != null) ? adapter : new NullSoundAdapter();
</code></pre>

<p>  }</p>

<p>  public static function get initialized():Boolean
  {</p>

<pre><code>return adapter != null;
</code></pre>

<p>  }</p>

<p>  public static function playSound(key:String):void
  {</p>

<pre><code>adapter.playSound(key);
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>You can also see an <code>init()</code> function (line 5) which is used to set the proper <strong><code>ISoundAdapter</code></strong> implementation. The <code>ISoundAdapter</code> defines just one method:</p>

<p>{% codeblock lang:actionscript3 %}
public interface ISoundAdapter
{
  function playSound(key:String):void;
}
{% endcodeblock %}</p>

<p>In line 7 of the <code>SoundDelegate</code> listing you will also notice that a <code>NullSoundAdapter</code> is assigned in case no instance gets passed to this method. This null-implementation silently ignores every call to <code>playSound()</code>. And this is how the <strong><code>playSound()</code></strong> top-level function looks like:</p>

<p>{% codeblock lang:actionscript3 %}
public function playSound(title:String):void
{
  if (!SoundDelegate.initialized)</p>

<pre><code>SoundDelegate.init();
</code></pre>

<p>  SoundDelegate.playSound(title);
}
{% endcodeblock %}</p>

<p>The function makes sure that the <code>SoundDelegate</code> class gets initialized. Because it will create the <code>NullSoundAdapter</code> by default, it is not very useful yet. Thats where the actual sound logic comes in. Whenever the logic is ready it calls the <code>SoundDelegate</code> and registers itself as <code>SoundAdapter</code> (line 6):</p>

<p>{% codeblock lang:actionscript3 %}
public class SoundLogic implements ISoundAdapter
{
  public function SoundLogic()
  {</p>

<pre><code>// Do this after sounds are loaded
SoundDelegate.init(this);
</code></pre>

<p>  }</p>

<p>  public function playSound(key:String):void
  {</p>

<pre><code>// play the sound for 'key'
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>The <code>SoundLogic</code> class implements the <code>ISoundAdapter</code> interface. Now whenever someone calls <code>playSound("foo")</code> the method <code>SoundLogic.playSound()</code> will be called with the string &ldquo;<code>foo</code>&rdquo;. Here you can now put all the logic that is necessary to play the sound for string &ldquo;<code>foo</code>&rdquo;.</p>

<h3>Adding new sounds</h3>

<p>Well you could now argue that, with this solution, adding new sounds still requires programmatic effort. In <a href="http://apps.facebook.com/magicland/">Magic Land</a> (the game I worked on <a href="http://www.wooga.com/">at wooga</a>) we also found a proper solution for this. Before I can explain it you have to know that in our game the sound logic is encapsulated within a module (<code>SWF</code>). This module is loaded lazy because it is less important than other parts of the game. A user can already play our game while the sounds are still loading.</p>

<p>The idea is to embed all sounds that could be triggered from the timeline in a single <code>FLA</code>, so the artists can maintain it. Sounds have to be exported for ActionScript, where the linkage name matches the string that will be later used for the <code>playSound()</code> method parameter. In order to make the sounds available to the sound logic we chose to compile them into the sound module itself. This way we get good compression and have no additional loading effort. Note however that this approach wouldn&rsquo;t make sense for large sound files.</p>

<p>{% /images/posts center <a href="http://blog.mattes-groeger.de/wp-content/uploads/2012/01/sound-library.png">http://blog.mattes-groeger.de/wp-content/uploads/2012/01/sound-library.png</a> sounds.fla %}</p>

<p>The question is now, how do we get new sounds automatically compiled into the sound module? What we did, we created a Sprite that contains all sounds. The <code>FLA</code> file then gets compiled into a <code>SWC</code> library and is part of the sound module classpath. To enforce the inclusion of the sound definitions the exported <code>SoundInclusionContainer</code> class is once referenced in the module:</p>

<p>{% codeblock lang:actionscript3 %}
// Sound module constructor
public function SoundModule()
{
  SoundInclusionContainer; // sound embedding
}
{% endcodeblock %}</p>

<p>This way, whenever the sound module gets compiled, all linked sounds within the container will be made available for the <code>playSound()</code> method call. Now the complete flow of adding and using timeline sounds is independent of the programmers while providing an optimized sound loading experience.</p>

<h2>Conclusion</h2>

<p>This post showed how artists can easily link timeline animations to a more complex logic. As this post is more about the general idea I didn&rsquo;t explain how the sound logic itself looks like.</p>

<p>I found another use cases for this pattern in our game <a href="http://apps.facebook.com/magicland/">Magic Land</a>. We use it for displaying visual effects. Similar to sounds they are part of a separate module that is lazy loaded. On low performance computers we could disable the effects completely.</p>

<p>Finally, lets have a look on the pros and cons of this pattern.</p>

<h3>Disadvantages</h3>

<p>The artists won&rsquo;t be able to hear the sound wile testing their sole assets. They have to start the game including the sound logic in order to hear something. In <a href="http://apps.facebook.com/magicland/">Magic Land</a> the artists are able to build the game locally on their computer (probably a topic for another blog post). So they can hear how it feels in the actual game.</p>

<p>Another drawback is that each asset <code>FLA</code> that makes use of the timeline actions has to link the <code>timeline-sound.swc</code>, which adds 2 Kb. A solution would be to exclude the library for compiling and enforce it to compile in the main application. But then running the asset <code>SWF</code> outside the final application/game throws errors and timeline animations won&rsquo;t be visible anymore.</p>

<h3>Advantages</h3>

<p>On the positive side programmers get less distracted by sound issues because artists can do everything on their own. They are free to add the <code>playSound()</code> call in any asset file, as long as they link the <code>timeline-sound.swc</code> into the <code>FLA</code> file.</p>

<p>At the same time the sounds itself can be loaded after more important stuff has been done loading. This leads to a much better user experience. Also imagine a user turned off sounds. Now you can just not load the sounds at all and the <code>playSound()</code> call will be silently ignored (null-implementation of <code>ISoundAdapter</code>).</p>

<h3>Sources</h3>

<p>You can find all source files for the timeline-sound library in <a href="https://github.com/MattesGroeger/as3-timeline-sound">this GitHub repository</a>. If you have any questions feel free to comment below. Enjoy!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Context-Aware Tasks]]></title>
    <link href="http://MattesGroeger.github.io/blog/2011/03/13/context-aware-tasks/"/>
    <updated>2011-03-13T20:03:00+01:00</updated>
    <id>http://MattesGroeger.github.io/blog/2011/03/13/context-aware-tasks</id>
    <content type="html"><![CDATA[<p>This article shows a useful way on how to combine the <a href="http://www.spicefactory.org/parsley/download.php">Spicelib</a> <a href="http://www.spicefactory.org/parsley/docs/2.3/manual/task.php#intro">Task Framework</a> with <a href="http://www.spicefactory.org/parsley/download.php">Parsley</a>. This way you can access everything from the context during the execution of a Task&hellip;</p>

<!-- more -->


<p>{% blockquote Parsley Documentation <a href="http://www.spicefactory.org/parsley/docs/3.3/manual/task.php#intro">http://www.spicefactory.org/parsley/docs/3.3/manual/task.php#intro</a> %}
The Task Framework is a general abstraction for asynchronous operations. It allows nesting / grouping of Tasks in TaskGroup instances for concurrent or sequential execution
{% endblockquote %}</p>

<p>One way to access the <code>Context</code> from within a <code>Task</code> would be to define it during the <a href="http://www.spicefactory.org/parsley/docs/2.3/manual/config.php" target="_blank">Parsley Configuration</a> (<code>Context</code>). But this would mean, that the <code>Task</code> will not be removed until the context gets destroyed. Because a <code>Task</code> is only active during a limited time, this doesn&rsquo;t make much sense.</p>

<p>Another approach would be, not to define the <code>Task</code> in the <code>Context</code> but passing in all the necessary dependencies within the constructor. Depending on the amount of required dependencies, the constructor can become quite big. Also <code>Parsley</code> features like <a href="http://www.spicefactory.org/parsley/docs/2.3/manual/messaging.php#intro" target="_blank">Messaging</a> are not directly supported anymore.</p>

<h2>Solution</h2>

<p>That&rsquo;s why this solution utilizes the <a href="http://www.spicefactory.org/parsley/docs/2.3/manual/lifecycle.php#dynamic" target="_blank">Dynamic Object</a> feature of Parsley. It allows to add any instance to the <code>Context</code> during runtime and also removing it again, if not required anymore. For a <code>Task</code> this means that it needs to be added before the <code>start()</code> is called, and removed after the <code>complete()</code> has been triggered.</p>

<p>This adding/removing happens through the <code>Context</code> interface of Parsley. It should happen automatically in the <code>Task</code> to reduce the amount of code to write. In order to not have to pass the <code>Context</code> to each <code>Task</code> it could just be set once in the parent <code>TaskGroup</code>. The child <code>Task</code> then accesses it via the <code>parent</code> getter:</p>

<p>{% codeblock lang:actionscript3 %}
public class SequentialContextTaskGroup extends SequentialTaskGroup implements IContextProvider
{
  private var _context:Context;</p>

<p>  public function SequentialContextTaskGroup(context:Context, name:String = null)
  {</p>

<pre><code>_context = context;

super(name);
</code></pre>

<p>  }</p>

<p>  public function get context():Context
  {</p>

<pre><code>return _context;
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>And this is how the <code>IContextProvider</code> interface looks like:</p>

<p>{% codeblock lang:actionscript3 %}
public interface IContextProvider
{
  function get context():Context;
}
{% endcodeblock %}</p>

<p>The following <code>AbstractContextTask</code> is then responsible for adding itself to the <code>Context</code> as soon as it is started. It also removes itself as soon as the <code>complete()</code>, <code>cancel()</code> or <code>skip()</code> has been called. Furthermore it provides a <code>doStartContext()</code> method (read more in the next paragraph).</p>

<p>{% codeblock lang:actionscript3 %}
public class AbstractContextTask extends Task
{
  private var _dynamicObject:DynamicObject;</p>

<p>  protected override function doStart():void
  {</p>

<pre><code>_dynamicObject = IContextProvider(parent).context.addDynamicObject(this);

doStartContext();
super.doStart();
</code></pre>

<p>  }</p>

<p>  protected function doStartContext():void
  {</p>

<pre><code>/* base implementation does nothing */
</code></pre>

<p>  }</p>

<p>  protected override function doCancel():void
  {</p>

<pre><code>cleanContext();
super.doCancel();
</code></pre>

<p>  }</p>

<p>  protected override function doSkip():void
  {</p>

<pre><code>cleanContext();
super.doSkip();
</code></pre>

<p>  }</p>

<p>  protected override function complete():Boolean
  {</p>

<pre><code>cleanContext();
return super.complete();
</code></pre>

<p>  }</p>

<p>  private function cleanContext():void
  {</p>

<pre><code>_dynamicObject.remove();
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>The following class is a concrete implementation of <code>AbstractContextTask</code>. That&rsquo;s why it gets the <code>HintComponent</code> injected (line 4). Please also note that this <code>Task</code> overrides the method <code>doStartContext()</code> (line 13). This way we ensure that the class already has been added to the <code>Context</code>.</p>

<p>{% codeblock lang:actionscript3 %}
public class ShowHintTask extends AbstractContextTask
{
  [Inject]
  public var hint:HintComponent;</p>

<p>  private var type:HintType;</p>

<p>  public function ShowHintTask(type:HintType)
  {</p>

<pre><code>this.type = type;
</code></pre>

<p>  }</p>

<p>  protected override function doStartContext():void
  {</p>

<pre><code>hint.showHint(type);

complete();
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>The following code shows how everything can be glued together. Note, that you don&rsquo;t have to pass the <code>Context</code> to each task.</p>

<p>{% codeblock lang:actionscript3 %}
public class TaskController
{
  [Inject]
  public var context:Context;</p>

<p>  [Init]
  public function initialize():void
  {</p>

<pre><code>var taskGroup:SequentialContextTaskGroup = new SequentialContextTaskGroup(context);

taskGroup.addTask(new ShowHintTask(HintType.ATTENTION));
taskGroup.addTask(new PointToTask(new Point(3, 5)));
// add more tasks here...

taskGroup.start();
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<h2>Summary</h2>

<p>This approach of <code>Context</code>-aware <code>Tasks</code> ensures that you don&rsquo;t have a lot of <code>Tasks</code> at the same time in the <code>Context</code>. The adding and removing from the <code>Context</code> happens in an encapsulated class. The <code>Task</code> itself can directly access injected objects during execution time.</p>

<h2>Links</h2>

<ul>
<li><a href="http://blog.mattes-groeger.de/actionscript/strong-typed-constants/">Strong typed constants</a></li></li>
<li><a href="http://www.spicefactory.org/parsley/docs/2.3/manual/task.php">Task framework documentation</a></li></li>
<li><a href="http://www.spicefactory.org/parsley/download.php">Parsley/Spicelib download</a></li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Label Validation with FlexUnit]]></title>
    <link href="http://MattesGroeger.github.io/blog/2011/01/18/label-validation-with-flexunit/"/>
    <updated>2011-01-18T22:36:00+01:00</updated>
    <id>http://MattesGroeger.github.io/blog/2011/01/18/label-validation-with-flexunit</id>
    <content type="html"><![CDATA[<p>While working in interdisciplinary teams where graphics are produced by artists and the code comes from the developers, a solid designer-developer work-flow is crucial. At my current project team at <a href="http://www.wooga.com">Wooga</a> we already established a very good work-flow. The artists can produce graphics and see them in the running application after committing them.</p>

<!-- more -->


<h2>The Problem</h2>

<p>In our project we use <a href="http://www.richardleggett.co.uk/blog/index.php/2010/03/08/flash_builder_and_flash_pro_asset_workflows">SWC asset libraries</a> to have a compile time check and strong typed access to all our graphics. To add logic to <code>MovieClip</code> frames you could either put the code directly on the timeline or the artist defines labels which are then utilized from the code. In order to keep the view separated from the code you should always use the label approach. But this is also risky if the artist accidentally deletes or renames a label. The code would then behave unexpectedly without knowing it. The only way to see the problem is to start the application and test all the <code>MovieClip</code> logic.</p>

<h2>The First Approach</h2>

<p>To protect the labels from unintended changes, our first approach was to check their existence wherever we used them in code. This means we had to provide a separate <code>Vector</code> that contained all the expected labels.</p>

<p>{% codeblock lang:actionscript3 %}
private static var labels:Vector.<String> = new Vector.<String>();
private var view:IconView;</p>

<p>public function IconMediator(view:IconView):void
{
  initializeLabels();
  assertLabelsExist(view);
}</p>

<p>private function initializeLabels():void
{
  if (labels.length == 0)</p>

<pre><code>labels.push(IconState.ON, IconState.OFF);
</code></pre>

<p>}</p>

<p>private function assertLabelsExist(view:ButtonRounded):void
{
  var requiredMatchesRemaining:int = labels.length;</p>

<p>  for each (var requiredLabel:String in labels)
  {</p>

<pre><code>for each (var label:FrameLabel in view.currentLabels)
{
  if (requiredLabel == label.name)
    requiredMatchesRemaining--;
}
</code></pre>

<p>  }</p>

<p>  if (requiredMatchesRemaining != 0)</p>

<pre><code>throw new IllegalArgumentError('IconView requires all labels: ' + labels);
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Beside this we defined the labels itself in an <a href="http://blog.mattes-groeger.de/actionscript/strong-typed-constants/">enumeration class</a> to provide strong typed access.</p>

<p>{% codeblock lang:actionscript3 %}
public class IconState
{
  public static const ON:IconState = new IconState(&ldquo;on&rdquo;);
  public static const OFF:IconState = new IconState(&ldquo;off&rdquo;);</p>

<p>  private var type:String;</p>

<p>  public function IconState(type:String)
  {</p>

<pre><code>this.type = type;
</code></pre>

<p>  }</p>

<p>  public function toString():String
  {</p>

<pre><code>return type;
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>This approach leads to three main problems:</p>

<ul>
<li>Depending on when the validation is executed in code, it could still happen that you don&rsquo;t see the problems immediately</li>
<li>We create a lot of code that is only necessary for validation but not for the application itself</li>
<li>We create redundancy because we have to maintain the <code>Vector</code> of expected labels and the enumeration class (<code>IconState</code>). When changing labels it is very likely that you forget to update the Vector.</li>
</ul>


<h2>The Solution</h2>

<p>Thats why we came up with a different approach. We moved the validation into the unit tests. Now the code is separated but still executed because of our integration server (Hudson with <a href="http://www.flexunit.org/" target="_blank">FlexUnit support</a>). The normal application code is now much slimmer and better readable. The artists/developers are automatically notified by mail if their changes break the tests.</p>

<p>To solve point 3 I wrote an assertion method that can reflect on enumeration classes and check all the defined labels on a certain MovieClip.</p>

<p>{% codeblock lang:actionscript3 %}
public function assertLabelEnum(target:MovieClip, enumClass:Class):void
{
  var classInfo:ClassInfo = ClassInfo.forClass(enumClass);
  var properties:Array = classInfo.getStaticProperties();
  var expectedLabel : String;
  var type:*;
  var labelCounter:int = 0;</p>

<p>  for each (var property : Property in properties)
  {</p>

<pre><code>type = property.getValue(enumClass);

if (type is String)
  expectedLabel = String(type);
else if (type is enumClass)
  type["toString"]();
else
  continue;

labelCounter++;
expectedLabel = type["toString"]();

assertLabel(expectedLabel, target);
</code></pre>

<p>  }</p>

<p>  assertEquals(&ldquo;Amount of expected labels differs from the amount of existing labels&rdquo;, labelCounter, target.currentLabels.length);
}
{% endcodeblock %}</p>

<p>This method internally calls another assertion method <code>assertLabel()</code>. This method can also be used independently for testing specific labels without using enumeration classes.</p>

<p>{% codeblock lang:actionscript3 %}
public function assertLabel(target:MovieClip, expectedLabel:String):void
{
  var found:Boolean = false;</p>

<p>  for each (var label:FrameLabel in target.currentLabels)
  {</p>

<pre><code>if (expectedLabel == label.name)
{
  found = true;
  break;
}
</code></pre>

<p>  }</p>

<p>  if (!found)</p>

<pre><code>fail("Expected label [" + expectedLabel + "] not found in " + target);
</code></pre>

<p>}
{% endcodeblock %}</p>

<p><em>Note:</em> I used the reflection library from spicelib to retrieve all the static members of the enumeration class. You can <a href="http://www.spicefactory.org/parsley/">download the library here</a>.</p>

<p>And this is how the test method would look like:</p>

<p>{% codeblock lang:actionscript3 %}
[Test]
public function test_icon_frame_labels():void
{
  assertLabelEnum(new IconView(), IconState);
}
{% endcodeblock %}</p>

<h2>Conclusion</h2>

<p>We made very good experiences with this approach because unintended changes on the labels no longer lead to awkward behavior in the application itself. And of course the application code can focus on the main logic and is therefor better readable.</p>
]]></content>
  </entry>
  
</feed>
